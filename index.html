<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Ascenso Pixel - Corregido</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive;
            color: white;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 4px solid #4a4e69;
        }

        canvas {
            display: block;
            background-color: #22223b;
        }

        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            width: 100%;
            text-align: center;
            font-size: 10px;
            color: #9a8c98;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="ui-layer">
        <div>NIVEL: <span id="level-display">1</span></div>
        <div style="margin-top:10px; color:#ff6b6b">MUERTES: <span id="death-display">0</span></div>
    </div>
    <div class="controls-hint">MOVER: Flechas/WASD | SALTAR: Z/Espacio | DASH: X/Shift | REINICIAR: R</div>
</div>

<script>
/**
 * MOTOR DEL JUEGO - VERSIÓN CORREGIDA
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- CONFIGURACIÓN ---
const TILE_SIZE = 40;
const GRAVITY = 0.6; // Ligeramente más pesado para mejor control
const FRICTION = 0.82;
const ACCEL = 0.8;
const MAX_SPEED = 6;
const JUMP_FORCE = -10;
const DASH_SPEED = 10;
const DASH_DURATION = 8; 
const DASH_COOLDOWN = 30;

const COLORS = {
    player: '#ff6b6b',
    wall: '#4a4e69',
    spike: '#c1121f',
    goal: '#fca311',
    bg: '#22223b',
    wind: 'rgba(100, 200, 255, 0.15)',
    particle: '#ffffff'
};

// --- INPUT ---
const keys = {
    left: false, right: false, up: false, down: false,
    jump: false, dash: false, restart: false
};

window.addEventListener('keydown', (e) => {
    if(e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
    if(e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
    if(e.key === 'ArrowUp' || e.key === 'w') keys.up = true;
    if(e.key === 'ArrowDown' || e.key === 's') keys.down = true;
    if(e.key === ' ' || e.key === 'z' || e.key === 'k') keys.jump = true;
    if(e.key === 'x' || e.key === 'Shift' || e.key === 'l') keys.dash = true;
    if(e.key === 'r' || e.key === 'R') keys.restart = true;
});

window.addEventListener('keyup', (e) => {
    if(e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
    if(e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
    if(e.key === 'ArrowUp' || e.key === 'w') keys.up = false;
    if(e.key === 'ArrowDown' || e.key === 's') keys.down = false;
    if(e.key === ' ' || e.key === 'z' || e.key === 'k') keys.jump = false;
    if(e.key === 'x' || e.key === 'Shift' || e.key === 'l') keys.dash = false;
    if(e.key === 'r' || e.key === 'R') keys.restart = false;
});

// --- CLASES ---

class Particle {
    constructor(x, y, color, speed, life) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = life;
        this.maxLife = life;
        this.size = Math.random() * 4 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
        this.size *= 0.9;
    }
    draw(ctx, camX, camY) {
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x - camX, this.y - camY, this.size, this.size);
        ctx.globalAlpha = 1;
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 24; 
        this.h = 24;
        this.vx = 0;
        this.vy = 0;
        this.grounded = false;
        this.canDoubleJump = false;
        
        this.dashing = false;
        this.dashTimer = 0;
        this.dashCooldownTimer = 0;
        this.dashDir = {x:0, y:0};
        
        this.facing = 1;
        this.trail = [];
    }

    update(map, entities) {
        // 1. Dash
        if (keys.dash && this.dashCooldownTimer <= 0 && !this.dashing) {
            this.startDash();
        }

        if (this.dashing) {
            this.dashTimer--;
            this.vx = this.dashDir.x * DASH_SPEED;
            this.vy = this.dashDir.y * DASH_SPEED;
            
            if(this.dashTimer % 2 === 0) {
                this.trail.push({x: this.x, y: this.y, alpha: 0.8});
            }

            if (this.dashTimer <= 0) {
                this.dashing = false;
                this.vx = 0;
                this.vy = 0;
                this.dashCooldownTimer = DASH_COOLDOWN;
            }
        } else {
            // 2. Movimiento Normal
            if (keys.left) {
                this.vx -= ACCEL;
                this.facing = -1;
            }
            if (keys.right) {
                this.vx += ACCEL;
                this.facing = 1;
            }

            this.vx *= FRICTION;
            this.vy += GRAVITY;

            // Zonas de viento (Corregido: fuerza reducida)
            entities.forEach(e => {
                if(e.type === 'wind' && this.checkOverlap(e)) {
                    this.vx += (e.vx || 0) * 0.15; // Fuerza mucho menor
                    this.vy += (e.vy || 0) * 0.15;
                }
            });

            if (Math.abs(this.vx) > MAX_SPEED) this.vx = MAX_SPEED * Math.sign(this.vx);
            if (this.vy > 12) this.vy = 12;

            // 3. Salto
            if (keys.jump) {
                if (this.grounded) {
                    this.vy = JUMP_FORCE;
                    this.grounded = false;
                    this.canDoubleJump = true;
                    this.spawnParticles(5);
                    keys.jump = false;
                } else if (this.canDoubleJump) {
                    this.vy = JUMP_FORCE * 0.85;
                    this.canDoubleJump = false;
                    this.spawnParticles(8);
                    keys.jump = false;
                }
            }
        }

        if (this.dashCooldownTimer > 0) this.dashCooldownTimer--;

        // 4. Colisiones y Movimiento
        this.x += this.vx;
        this.checkCollision(map, 'x', entities);
        this.y += this.vy;
        this.checkCollision(map, 'y', entities);

        if (this.y > map.height * TILE_SIZE + 100) die();

        if(this.trail.length > 5) this.trail.shift();
    }

    startDash() {
        this.dashing = true;
        this.dashTimer = DASH_DURATION;
        let dx = 0, dy = 0;
        if (keys.left) dx = -1;
        if (keys.right) dx = 1;
        if (keys.up) dy = -1;
        if (keys.down) dy = 1;
        if (dx === 0 && dy === 0) dx = this.facing;
        else if (dx !== 0 && dy !== 0) {
            const len = Math.sqrt(dx*dx + dy*dy);
            dx /= len;
            dy /= len;
        }
        this.dashDir = {x: dx, y: dy};
        this.spawnParticles(10);
    }

    checkCollision(map, axis, entities) {
        let left = Math.floor(this.x / TILE_SIZE);
        let right = Math.floor((this.x + this.w) / TILE_SIZE);
        let top = Math.floor(this.y / TILE_SIZE);
        let bottom = Math.floor((this.y + this.h) / TILE_SIZE);

        // Colisión con Mapa Estático
        for (let y = top; y <= bottom; y++) {
            for (let x = left; x <= right; x++) {
                let tile = map.getTile(x, y);
                if (tile === '#') { 
                    if (axis === 'x') {
                        if (this.vx > 0) this.x = x * TILE_SIZE - this.w - 0.01;
                        if (this.vx < 0) this.x = (x + 1) * TILE_SIZE + 0.01;
                        this.vx = 0;
                        if(this.dashing) this.dashTimer = 0;
                    } else {
                        if (this.vy > 0) {
                            this.y = y * TILE_SIZE - this.h - 0.01;
                            this.grounded = true;
                            this.canDoubleJump = false;
                        }
                        if (this.vy < 0) {
                            this.y = (y + 1) * TILE_SIZE + 0.01;
                        }
                        this.vy = 0;
                        if(this.dashing) this.dashTimer = 0;
                    }
                } else if (tile === '^') { 
                    // Pinchos estáticos
                    if (this.checkRectOverlap(this.x, this.y, this.w, this.h, x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE)) {
                        die();
                    }
                } else if (tile === 'E') { 
                    nextLevel();
                }
            }
        }

        // Colisión con Entidades (Pinchos móviles, Plataformas)
        entities.forEach(e => {
            if (e.type === 'spike') {
                if (this.checkRectOverlap(this.x, this.y, this.w, this.h, e.x, e.y, e.w, e.h)) {
                    die();
                }
            } else if (e.type === 'moving_platform') {
                // Plataforma móvil
                if (this.checkRectOverlap(this.x, this.y, this.w, this.h, e.x, e.y, e.w, e.h)) {
                    // Colisión simple: Si estamos cayendo y tocamos la parte superior
                    // Usamos una tolerancia pequeña para permitir "aterrizar"
                    if (axis === 'y' && this.vy >= 0 && (this.y + this.h) <= (e.y + e.h/2 + 10)) {
                        this.y = e.y - this.h;
                        this.grounded = true;
                        this.canDoubleJump = false;
                        this.vy = 0;
                        // Mover al jugador con la plataforma
                        this.x += e.vx; 
                    } else {
                        // Empujar si chocamos de lado (opcional, pero ayuda a no atravesar)
                        if (axis === 'x') {
                             if (this.vx > 0) this.x = e.x - this.w - 0.01;
                             else this.x = e.x + e.w + 0.01;
                             this.vx = 0;
                        }
                    }
                }
            }
        });
    }

    checkRectOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
        return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
    }

    checkOverlap(rect) {
        return this.checkRectOverlap(this.x, this.y, this.w, this.h, rect.x, rect.y, rect.w, rect.h);
    }

    spawnParticles(count) {
        for(let i=0; i<count; i++) {
            particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, COLORS.particle, 4, 20));
        }
    }

    draw(ctx, camX, camY) {
        this.trail.forEach(t => {
            ctx.fillStyle = `rgba(255, 107, 107, ${t.alpha})`;
            ctx.fillRect(t.x - camX, t.y - camY, this.w, this.h);
            t.alpha -= 0.1;
        });

        ctx.fillStyle = COLORS.player;
        let drawW = this.w;
        let drawH = this.h;
        let drawX = this.x;
        let drawY = this.y;

        if(!this.grounded && Math.abs(this.vy) > 2) {
            drawW = this.w * 0.8;
            drawH = this.h * 1.2;
            drawX += (this.w - drawW)/2;
        }

        ctx.fillRect(drawX - camX, drawY - camY, drawW, drawH);
        
        ctx.fillStyle = 'white';
        let eyeOff = this.facing === 1 ? 4 : -4;
        ctx.fillRect(drawX - camX + drawW/2 + eyeOff - 2, drawY - camY + 4, 4, 4);
    }
}

// --- GESTIÓN DE NIVELES ---

const levels = [
    [ // NIVEL 1: Básico
        "####################",
        "#..................#",
        "#..................#",
        "#P.................#",
        "#####...^^^...#####",
        "#..................#",
        "#.......###........#",
        "#...###.....###....#",
        "#..................#",
        "#.........E........#",
        "####################"
    ],
    [ // NIVEL 2: Plataformas Móviles
        "####################",
        "#E.................#",
        "###................#",
        "#.......M..........#",
        "#.....#####........#",
        "#..................#",
        "#..........M.......#",
        "#P.......#####.....#",
        "####...............#",
        "#^^^^^^^^^^^^^^^^^^#",
        "####################"
    ],
    [ // NIVEL 3: Viento y Precisión (REPARADO)
        "####################",
        "#..................#",
        "#E.................#",
        "###.......^^^......#",
        "#.......#####......#",
        "#..................#",
        "#...WWWWWWWW.......#",
        "#...#.....#........#",
        "#...#..P..#........#",
        "####################"
    ],
    [ // NIVEL 4: El Reto Final
        "####################",
        "#E.................#",
        "###...^^^...M......#",
        "#.....###........#.#",
        "#..............M...#",
        "#...W...M...W......#",
        "#...#...#...#......#",
        "#...#...#...#...^^^#",
        "#P..#...#...#..#####",
        "####################"
    ]
];

let currentLevelIdx = 0;
let mapData = [];
let entities = [];
let player;
let particles = [];
let deaths = 0;
let camera = {x: 0, y: 0};
let gameState = 'playing';

function loadLevel(idx) {
    if (idx >= levels.length) {
        gameState = 'won';
        return;
    }
    
    currentLevelIdx = idx;
    document.getElementById('level-display').innerText = idx + 1;
    
    const layout = levels[idx];
    mapData = [];
    entities = [];
    particles = [];
    
    const h = layout.length;
    const w = layout[0].length;
    
    for(let y=0; y<h; y++) {
        let row = [];
        for(let x=0; x<w; x++) {
            let char = layout[y][x];
            if(char === 'P') {
                player = new Player(x * TILE_SIZE, y * TILE_SIZE);
                row.push('.');
            } else if (char === 'M') {
                // Plataforma más lenta y estable
                entities.push({
                    type: 'moving_platform',
                    x: x * TILE_SIZE, y: y * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE/2,
                    originX: x * TILE_SIZE, originY: y * TILE_SIZE,
                    vx: 0, vy: 0, range: 80, offset: Math.random() * 10 // Offset aleatorio para variedad
                });
                row.push('.');
            } else if (char === 'W') {
                entities.push({
                    type: 'wind',
                    x: x * TILE_SIZE, y: y * TILE_SIZE, w: TILE_SIZE, h: TILE_SIZE,
                    vx: 1, vy: 0 
                });
                row.push('.');
            } else {
                row.push(char);
            }
        }
        mapData.push(row);
    }

    camera.x = player.x - canvas.width/2;
    camera.y = player.y - canvas.height/2;
}

function getTile(x, y) {
    if (y < 0 || y >= mapData.length || x < 0 || x >= mapData[0].length) return '.';
    return mapData[y][x];
}

function die() {
    deaths++;
    document.getElementById('death-display').innerText = deaths;
    
    for(let i=0; i<20; i++) {
        particles.push(new Particle(player.x + player.w/2, player.y + player.h/2, COLORS.player, 6, 40));
    }
    
    // Reinicio seguro
    loadLevel(currentLevelIdx);
}

function nextLevel() {
    loadLevel(currentLevelIdx + 1);
}

// --- BUCLE PRINCIPAL ---

function update() {
    if (gameState === 'won') {
        if(keys.restart) {
            deaths = 0;
            document.getElementById('death-display').innerText = 0;
            gameState = 'playing';
            loadLevel(0);
        }
        return;
    }

    if (keys.restart) {
        // Pequeño delay o check para evitar reinicios infinitos en un frame
        // Pero loadLevel ya resetea la posición, así que debería estar bien.
        loadLevel(currentLevelIdx);
    }

    player.update({getTile, height: mapData.length, width: mapData[0].length}, entities);

    // Actualizar entidades
    entities.forEach(e => {
        if(e.type === 'moving_platform') {
            // Velocidad reducida (0.03 en vez de 0.05)
            e.offset += 0.03;
            e.x = e.originX + Math.sin(e.offset) * e.range;
            // Calcular velocidad para empujar al jugador
            e.vx = Math.cos(e.offset) * e.range * 0.03; 
        }
    });

    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        if (particles[i].life <= 0) particles.splice(i, 1);
    }

    let targetCamX = player.x - canvas.width / 2 + player.w/2;
    let targetCamY = player.y - canvas.height / 2 + player.h/2;
    
    camera.x += (targetCamX - camera.x) * 0.1;
    camera.y += (targetCamY - camera.y) * 0.1;
}

function draw() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(-camera.x * 0.5, -camera.y * 0.5);
    ctx.fillStyle = '#2a2e45';
    ctx.fillRect(100, 400, 200, 300);
    ctx.fillRect(500, 300, 300, 400);
    ctx.restore();

    ctx.save();
    ctx.translate(-Math.floor(camera.x), -Math.floor(camera.y));

    for (let y = 0; y < mapData.length; y++) {
        for (let x = 0; x < mapData[0].length; x++) {
            let tile = mapData[y][x];
            let px = x * TILE_SIZE;
            let py = y * TILE_SIZE;

            if (tile === '#') {
                ctx.fillStyle = COLORS.wall;
                ctx.fillRect(px, py, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = '#5c6080';
                ctx.fillRect(px + 4, py + 4, TILE_SIZE - 8, TILE_SIZE - 8);
            } else if (tile === '^') {
                ctx.fillStyle = COLORS.spike;
                ctx.beginPath();
                ctx.moveTo(px, py + TILE_SIZE);
                ctx.lineTo(px + TILE_SIZE / 2, py);
                ctx.lineTo(px + TILE_SIZE, py + TILE_SIZE);
                ctx.fill();
            } else if (tile === 'E') {
                ctx.fillStyle = COLORS.goal;
                ctx.fillRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
                ctx.strokeStyle = 'white';
                ctx.strokeRect(px + 10, py + 10, TILE_SIZE - 20, TILE_SIZE - 20);
            }
        }
    }

    entities.forEach(e => {
        if(e.type === 'moving_platform') {
            ctx.fillStyle = '#9a8c98';
            ctx.fillRect(e.x, e.y, e.w, e.h);
            // Detalle visual
            ctx.fillStyle = '#4a4e69';
            ctx.fillRect(e.x + 5, e.y + 5, e.w - 10, e.h - 10);
        } else if (e.type === 'wind') {
            ctx.fillStyle = COLORS.wind;
            ctx.fillRect(e.x, e.y, e.w, e.h);
            ctx.fillStyle = 'white';
            ctx.fillRect(e.x + 10, e.y + 15, 20, 4);
            ctx.fillRect(e.x + 25, e.y + 12, 5, 5);
        }
    });

    if(gameState === 'playing') player.draw(ctx, 0, 0);
    particles.forEach(p => p.draw(ctx, 0, 0));

    ctx.restore();

    if (gameState === 'won') {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fca311';
        ctx.font = '40px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText("¡NIVEL COMPLETADO!", canvas.width/2, canvas.height/2 - 20);
        ctx.fillStyle = 'white';
        ctx.font = '20px "Press Start 2P"';
        ctx.fillText(`Muertes totales: ${deaths}`, canvas.width/2, canvas.height/2 + 30);
        ctx.fillText("Presiona R para reiniciar", canvas.width/2, canvas.height/2 + 70);
    }
}

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

loadLevel(0);
loop();

</script>
</body>
</html>
